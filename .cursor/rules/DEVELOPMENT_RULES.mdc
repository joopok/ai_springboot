---
description: 
globs: 
alwaysApply: true
---
# Spring Boot PM7 Project Development Rules & Guidelines

## 🎯 PROJECT OVERVIEW

**Project Name**: PM7 (Project Management System v7)
**Architecture**: Spring Boot 2.7.x with MyBatis, MariaDB, JWT Authentication
**Current Status**: Legacy modernization project with security-first approach

---

## 🚀 CORE DEVELOPMENT PRINCIPLES

### 1. **CHAIN-OF-THOUGHT DEVELOPMENT**
- Break down complex features into logical, sequential steps
- Document decision-making process in code comments
- Use incremental development with clear milestone markers
- Apply the "Thinking Step by Step" approach for complex business logic

### 2. **ROLE-BASED PROMPT ENGINEERING**
```
As an Expert Spring Boot Architect, you will:
- Design secure, scalable solutions
- Follow enterprise-grade patterns
- Implement defensive programming practices
- Optimize for maintainability and performance
```

### 3. **FEW-SHOT LEARNING PATTERNS**
Apply proven examples from the codebase:
- **Controller Pattern**: RESTful endpoints with ApiResponse wrapper
- **Service Pattern**: Interface-implementation with transaction management
- **Security Pattern**: JWT-based authentication with role validation
- **Error Handling**: Global exception handler with structured responses

---

## 🏗️ ARCHITECTURAL STANDARDS

### **Domain-Driven Design (DDD) Application**
```
src/main/java/com/example/pm7/
├── controller/          # Presentation Layer
├── service/            # Application Layer  
├── model/              # Domain Layer
├── mapper/             # Infrastructure Layer (MyBatis)
├── config/             # Cross-cutting Concerns
├── dto/                # Data Transfer Objects
└── exception/          # Exception Handling
```

### **Layered Architecture Rules**
1. **Controllers** → Only handle HTTP concerns, delegate to services
2. **Services** → Business logic, transaction boundaries
3. **Mappers** → Data access layer, SQL mapping
4. **Models** → Domain entities with proper validation
5. **DTOs** → API contracts, input/output transformation

---

## 🔒 SECURITY-FIRST DEVELOPMENT

### **Authentication & Authorization Framework**
```yaml
Security Stack:
- JWT Tokens: 24h expiration, 7-day refresh
- BCrypt: Password hashing with salt
- Role-based Access Control (RBAC)
- Session Management: Stateless with Redis caching
```

### **Security Implementation Checklist**
- [ ] Input validation on all endpoints
- [ ] SQL injection prevention (MyBatis parameterized queries)
- [ ] XSS protection via response encoding
- [ ] CSRF protection for state-changing operations
- [ ] Rate limiting on authentication endpoints
- [ ] Audit logging for sensitive operations

### **Example Security Pattern**
```java
@RestController
@RequestMapping("/api/secure")
@PreAuthorize("hasRole('USER')")
public class SecureController {
    
    @PostMapping("/action")
    @PreAuthorize("hasRole('ADMIN') or @securityService.isOwner(authentication.name, #id)")
    public ResponseEntity<ApiResponse<Void>> performAction(
            @Valid @RequestBody ActionRequest request,
            Authentication authentication) {
        // 방어적 프로그래밍: 입력 검증 및 권한 재확인
        securityService.validateAccess(authentication, request);
        // 비즈니스 로직 실행
        return ResponseEntity.ok(ApiResponse.success(null));
    }
}
```

---

## 📊 DATA MANAGEMENT PATTERNS

### **MyBatis Best Practices**
```xml
<!-- 성능 최적화된 쿼리 예제 -->
<select id="findUserWithRoles" resultMap="UserResultMap">
    SELECT u.*, r.role_name 
    FROM users u 
    LEFT JOIN user_roles ur ON u.user_id = ur.user_id
    LEFT JOIN roles r ON ur.role_id = r.role_id
    WHERE u.user_id = #{userId}
    AND u.is_active = 1
</select>

<!-- 동적 쿼리 with 안전한 필터링 -->
<select id="searchUsers" resultType="User">
    SELECT * FROM users
    <where>
        <if test="name != null and name != ''">
            AND name LIKE CONCAT('%', #{name}, '%')
        </if>
        <if test="status != null">
            AND status = #{status}
        </if>
        AND is_deleted = 0
    </where>
    ORDER BY created_date DESC
    LIMIT #{offset}, #{limit}
</select>
```

### **Transaction Management Strategy**
```java
@Service
@Transactional(readOnly = true) // 기본적으로 읽기 전용
public class UserServiceImpl implements UserService {
    
    @Override
    @Transactional // 쓰기 작업 시에만 트랜잭션 활성화
    @Retryable(value = {DataAccessException.class}, maxAttempts = 3)
    public void updateUser(User user) {
        // 비즈니스 룰 검증
        validateBusinessRules(user);
        
        // 감사 로그 생성
        auditService.logUserUpdate(user);
        
        // 실제 업데이트 수행
        userMapper.update(user);
        
        // 캐시 무효화
        cacheManager.evict("users", user.getId());
    }
}
```

---

## 🎨 API DESIGN EXCELLENCE

### **RESTful API Standards**
```
HTTP Methods Mapping:
GET    /api/users          # 사용자 목록 조회
GET    /api/users/{id}     # 특정 사용자 조회
POST   /api/users          # 새 사용자 생성
PUT    /api/users/{id}     # 사용자 전체 업데이트
PATCH  /api/users/{id}     # 사용자 부분 업데이트
DELETE /api/users/{id}     # 사용자 삭제
```

### **Consistent Response Format**
```java
public class ApiResponse<T> {
    private boolean success;
    private T data;
    private String message;
    private LocalDateTime timestamp;
    private Map<String, Object> metadata; // 페이징, 필터링 정보
    
    // 성공 응답 팩토리 메서드
    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, data, message);
    }
    
    // 페이징을 포함한 성공 응답
    public static <T> ApiResponse<List<T>> successWithPaging(
            List<T> data, int page, int size, long total) {
        ApiResponse<List<T>> response = new ApiResponse<>(true, data, null);
        response.addMetadata("page", page);
        response.addMetadata("size", size);
        response.addMetadata("total", total);
        response.addMetadata("totalPages", (int) Math.ceil((double) total / size));
        return response;
    }
}
```

### **Error Response Standardization**
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ApiResponse<Map<String, String>>> handleValidation(
            ValidationException ex) {
        Map<String, String> errors = ex.getFieldErrors();
        return ResponseEntity.badRequest()
                .body(ApiResponse.error("입력 데이터 검증 실패", errors));
    }
    
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiResponse<Void>> handleBusiness(BusinessException ex) {
        log.warn("비즈니스 규칙 위반: {}", ex.getMessage());
        return ResponseEntity.status(ex.getHttpStatus())
                .body(ApiResponse.error(ex.getMessage()));
    }
}
```

---

## 🧪 TESTING EXCELLENCE

### **Test Pyramid Implementation**
```
Unit Tests (70%): Service layer, utility classes
Integration Tests (20%): Repository layer, external APIs  
E2E Tests (10%): Critical user journeys
```

### **Test-Driven Development Pattern**
```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock private UserMapper userMapper;
    @Mock private PasswordEncoder passwordEncoder;
    @InjectMocks private UserServiceImpl userService;
    
    @Test
    @DisplayName("사용자 생성 시 비밀번호가 암호화되어야 한다")
    void should_EncryptPassword_When_CreatingUser() {
        // Given: 테스트 데이터 준비
        User user = User.builder()
                .username("testuser")
                .password("plainPassword")
                .build();
        
        when(passwordEncoder.encode("plainPassword"))
                .thenReturn("$2a$10$encrypted");
        
        // When: 테스트 실행
        userService.register(user);
        
        // Then: 결과 검증
        verify(passwordEncoder).encode("plainPassword");
        verify(userMapper).insert(argThat(u -> 
                u.getPassword().equals("$2a$10$encrypted")));
    }
}
```

### **Integration Test Configuration**
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestPropertySource(locations = "classpath:application-test.yml")
@Sql(executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD, 
     scripts = "classpath:test-data.sql")
@Sql(executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD, 
     scripts = "classpath:cleanup.sql")
class UserIntegrationTest {
    
    @Autowired private TestRestTemplate restTemplate;
    @Autowired private UserMapper userMapper;
    
    @Test
    void 사용자_생성_통합_테스트() {
        // Given
        CreateUserRequest request = new CreateUserRequest("newuser", "password");
        
        // When
        ResponseEntity<ApiResponse> response = restTemplate.postForEntity(
                "/api/users", request, ApiResponse.class);
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(userMapper.findByUsername("newuser")).isNotNull();
    }
}
```

---

## 📈 PERFORMANCE OPTIMIZATION

### **Caching Strategy**
```java
@Service
public class UserServiceImpl implements UserService {
    
    @Cacheable(value = "users", key = "#id", condition = "#id != null")
    public User findById(Long id) {
        return userMapper.findById(id);
    }
    
    @CacheEvict(value = "users", key = "#user.id")
    @CachePut(value = "users", key = "#result.id")
    public User update(User user) {
        userMapper.update(user);
        return userMapper.findById(user.getId());
    }
    
    @CacheEvict(value = "users", allEntries = true)
    public void clearUserCache() {
        // 전체 사용자 캐시 무효화
    }
}
```

### **Database Optimization Guidelines**
```sql
-- 인덱스 최적화 예제
CREATE INDEX idx_users_username_status ON users(username, status);
CREATE INDEX idx_notices_created_date ON notices(created_date DESC);
CREATE INDEX idx_events_status_date ON events(status, event_date);

-- 복합 쿼리 최적화
SELECT u.username, u.email, 
       COUNT(n.notice_id) as notice_count
FROM users u
LEFT JOIN notices n ON u.user_id = n.created_by
WHERE u.is_active = 1
GROUP BY u.user_id, u.username, u.email
HAVING notice_count > 0
ORDER BY notice_count DESC
LIMIT 10;
```

---

## 🔍 MONITORING & OBSERVABILITY

### **Structured Logging Pattern**
```java
@Slf4j
@Component
public class BusinessService {
    
    public void processOrder(Order order) {
        try (MDCCloseable mdcCloseable = MDC.putCloseable("orderId", order.getId())) {
            log.info("주문 처리 시작 - 금액: {}, 상품수: {}", 
                    order.getTotalAmount(), order.getItemCount());
            
            // 비즈니스 로직 실행
            
            log.info("주문 처리 완료 - 소요시간: {}ms", 
                    System.currentTimeMillis() - startTime);
        } catch (BusinessException e) {
            log.error("주문 처리 실패 - 사유: {}", e.getMessage(), e);
            throw e;
        }
    }
}
```

### **Health Check Implementation**
```java
@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Autowired private DataSource dataSource;
    @Autowired private RedisTemplate redisTemplate;
    
    @Override
    public Health health() {
        try {
            // 데이터베이스 연결 확인
            try (Connection conn = dataSource.getConnection()) {
                if (!conn.isValid(5)) {
                    return Health.down().withDetail("database", "연결 불가").build();
                }
            }
            
            // Redis 연결 확인
            redisTemplate.opsForValue().get("health-check");
            
            return Health.up()
                    .withDetail("database", "정상")
                    .withDetail("redis", "정상")
                    .build();
                    
        } catch (Exception e) {
            return Health.down()
                    .withDetail("error", e.getMessage())
                    .build();
        }
    }
}
```

---

## 🔧 DEVELOPMENT WORKFLOW

### **Git Branch Strategy**
```
main           # 프로덕션 배포 브랜치
├── develop    # 개발 통합 브랜치
├── feature/   # 기능 개발 브랜치
├── hotfix/    # 긴급 수정 브랜치
└── release/   # 릴리스 준비 브랜치
```

### **Commit Message Convention**
```
feat: 새로운 기능 추가
fix: 버그 수정
docs: 문서 수정
style: 코드 스타일 변경 (포맷팅, 세미콜론 등)
refactor: 코드 리팩토링
test: 테스트 코드 추가/수정
chore: 빌드 프로세스 또는 보조 도구 변경

예시:
feat(auth): JWT 토큰 갱신 기능 구현
fix(user): 사용자 검색 시 NPE 발생 이슈 해결
docs(api): 사용자 API 문서 업데이트
```

### **Code Review Checklist**
- [ ] 비즈니스 로직이 요구사항과 일치하는가?
- [ ] 보안 취약점이 없는가? (SQL Injection, XSS 등)
- [ ] 성능 이슈가 없는가? (N+1 쿼리, 메모리 누수 등)
- [ ] 테스트 커버리지가 충분한가? (최소 80%)
- [ ] 코드가 읽기 쉽고 유지보수가 가능한가?
- [ ] 에러 처리가 적절히 구현되었는가?

---

## 📚 KNOWLEDGE MANAGEMENT

### **Documentation Standards**
```java
/**
 * 사용자 관리 서비스
 * 
 * 이 서비스는 사용자의 생성, 조회, 수정, 삭제 기능을 제공합니다.
 * 모든 비밀번호는 BCrypt로 암호화되며, 사용자 활동은 감사 로그에 기록됩니다.
 * 
 * 주요 기능:
 * - 사용자 등록 및 인증
 * - 역할 기반 권한 관리
 * - 사용자 프로필 관리
 * 
 * @author Development Team
 * @version 1.0
 * @since 2024-01-01
 */
@Service
public class UserServiceImpl implements UserService {
    
    /**
     * 새로운 사용자를 등록합니다.
     * 
     * @param user 등록할 사용자 정보 (비밀번호는 평문)
     * @throws DuplicateUsernameException 사용자명이 이미 존재하는 경우
     * @throws InvalidPasswordException 비밀번호 정책에 맞지 않는 경우
     */
    @Override
    @Transactional
    public void register(User user) {
        // 구현 내용...
    }
}
```

### **API Documentation with OpenAPI**
```java
@RestController
@RequestMapping("/api/users")
@Tag(name = "사용자 관리", description = "사용자 등록, 조회, 수정, 삭제 API")
public class UserController {
    
    @PostMapping
    @Operation(
        summary = "새 사용자 등록",
        description = "시스템에 새로운 사용자를 등록합니다. 비밀번호는 자동으로 암호화됩니다."
    )
    @ApiResponses({
        @ApiResponse(responseCode = "201", description = "사용자 등록 성공"),
        @ApiResponse(responseCode = "400", description = "잘못된 입력 데이터"),
        @ApiResponse(responseCode = "409", description = "이미 존재하는 사용자명")
    })
    public ResponseEntity<ApiResponse<User>> createUser(
            @Parameter(description = "등록할 사용자 정보", required = true)
            @Valid @RequestBody CreateUserRequest request) {
        // 구현 내용...
    }
}
```

---

## 🎯 CONTINUOUS IMPROVEMENT

### **Code Quality Metrics**
```yaml
Quality Gates:
  Code Coverage: >= 80%
  Cyclomatic Complexity: <= 10
  Maintainability Index: >= 60
  Technical Debt Ratio: <= 5%
  Duplication: <= 3%
```

### **Performance Benchmarks**
```yaml
Response Time Targets:
  Simple CRUD Operations: < 100ms
  Complex Queries: < 500ms
  Report Generation: < 2s
  File Upload: < 5s

Throughput Targets:
  Concurrent Users: 100+
  Requests per Second: 1000+
  Database Connections: 20 max
```

---

## 🚦 DEPLOYMENT STRATEGY

### **Environment Configuration**
```yaml
# application-dev.yml
spring:
  profiles:
    active: dev
  datasource:
    url: jdbc:mariadb://localhost:3306/pm7_dev
    hikari:
      maximum-pool-size: 5
  security:
    oauth2:
      client:
        registration:
          test-client:
            client-id: dev-client
logging:
  level:
    com.example.pm7: DEBUG

# application-prod.yml
spring:
  profiles:
    active: prod
  datasource:
    hikari:
      maximum-pool-size: 20
      leak-detection-threshold: 60000
  security:
    require-ssl: true
logging:
  level:
    com.example.pm7: INFO
    org.springframework.security: WARN
```

### **Blue-Green Deployment Process**
1. **Pre-deployment Checks**
   - 데이터베이스 마이그레이션 스크립트 검증
   - 설정 파일 무결성 확인
   - 종속성 충돌 검사

2. **Deployment Steps**
   - Green 환경에 새 버전 배포
   - Health check 및 smoke test 실행
   - 트래픽 점진적 전환 (10% → 50% → 100%)
   - Blue 환경 롤백 준비 상태 유지

3. **Post-deployment Monitoring**
   - 애플리케이션 메트릭 모니터링
   - 오류율 및 응답시간 추적
   - 사용자 피드백 수집

---

## 📋 COMPLIANCE & GOVERNANCE

### **Data Protection (GDPR/CCPA Compliance)**
```java
@Entity
@Table(name = "users")
public class User {
    
    @PersonalData // 개인정보 식별 어노테이션
    @Column(name = "email")
    private String email;
    
    @SensitiveData // 민감정보 식별 어노테이션
    @Column(name = "phone")
    private String phoneNumber;
    
    @JsonIgnore // API 응답에서 제외
    @Column(name = "password")
    private String password;
}

@Component
public class DataRetentionService {
    
    @Scheduled(cron = "0 0 2 * * *") // 매일 새벽 2시 실행
    public void cleanupExpiredData() {
        // 비활성 사용자 데이터 익명화 (90일 기준)
        userService.anonymizeInactiveUsers(90);
        
        // 삭제 요청된 데이터 물리적 삭제 (30일 기준)
        userService.physicalDeleteRequestedUsers(30);
    }
}
```

### **Audit Trail Implementation**
```java
@Entity
@Table(name = "audit_log")
public class AuditLog {
    private Long id;
    private String userId;
    private String action;
    private String resourceType;
    private String resourceId;
    private String details;
    private LocalDateTime timestamp;
    private String ipAddress;
    private String userAgent;
}

@Aspect
@Component
public class AuditAspect {
    
    @Around("@annotation(Auditable)")
    public Object audit(ProceedingJoinPoint joinPoint) throws Throwable {
        // 감사 로그 생성 및 저장
        return joinPoint.proceed();
    }
}
```

---

## 🎯 SUCCESS METRICS

### **Technical KPIs**
- **Availability**: 99.9% uptime
- **Performance**: < 200ms average response time
- **Security**: Zero critical vulnerabilities
- **Quality**: 90%+ test coverage
- **Maintainability**: < 5% technical debt

### **Business KPIs**
- **User Satisfaction**: > 4.5/5.0 rating
- **Feature Adoption**: > 80% within 30 days
- **Error Rate**: < 0.1% of total requests
- **Time to Market**: < 2 weeks for minor features

---

*이 문서는 Spring Boot PM7 프로젝트의 개발 표준을 정의하며, 최신 기술 동향과 모범 사례를 반영하여 지속적으로 업데이트됩니다.*

**Last Updated**: 2024-12-19
**Version**: 1.0
**Next Review**: 2024-Q2 